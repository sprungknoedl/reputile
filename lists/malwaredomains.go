package lists

import (
	"fmt"
	"strings"

	"github.com/sprungknoedl/reputile/model"
)

var malwaredomainsCategories = map[string]string{
	"phishing":    "phishing",
	"malicious":   "malware",
	"attack_page": "attacker",
	"attackpage":  "attacker",
	"malware":     "malware",
	"botnet":      "botnet",
	"bedep":       "malware",
	"zeus":        "malware",
	"ransomware":  "malware",
	"malspam":     "malware",
	"simda":       "malware",
	"cryptowall":  "malware",
}

var malwaredomains = List{
	Key:         "malwaredomains.com",
	Name:        "DNS-BH â€“ Malware Domain Blocklist",
	URL:         "http://www.malwaredomains.com/",
	Description: `The DNS-BH project creates and maintains a listing of domains that are known to be used to propagate malware and spyware. This project creates the Bind and Windows zone files required to serve fake replies to localhost for any requests to these, thus preventing many spyware installs and reporting.`,
	Iterator: TSV(
		"http://mirror1.malwaredomains.com/files/domains.txt",
		func(row []string) *model.Entry {
			var e *model.Entry
			if strings.HasPrefix(row[0], "20") {
				// row has a next validation info
				e = &model.Entry{
					Domain:      row[1],
					Category:    row[2],
					Description: fmt.Sprintf("%s marked it as %s", row[3], row[2]),
				}
			} else {
				// row has no next validation info, this tricks the csv parser
				e = &model.Entry{
					Domain:      row[0],
					Category:    row[1],
					Description: fmt.Sprintf("%s marked it as %s", row[2], row[1]),
				}
			}

			if category, ok := malwaredomainsCategories[e.Category]; ok {
				e.Category = category
				return e
			}

			return nil
		}),
}

func init() {
	Lists = append(Lists, malwaredomains)
}
